<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="xxe注入 前置知识 XML文档 要了解XXE漏洞，那么先得了解一下有关XML的基础知识。 XML是一种非常流行的标记语言，在1990年代后期首次标"><meta name=keywords content=",sec/javasec"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://l1uyun.one/posts/2024/07/javasec-xxe/><title>javasec-xxe | l1uyun☁️ — l1uyun's Blog
</title><link rel=stylesheet href=https://l1uyun.one/main.7ec86b545988b95db913eae589911b139b09ce5bdcae9ce4a659ba5efa58ffe3.css integrity="sha256-fshrVFmIuV25E+rliZEbE5sJzlvcrpzkplm6XvpY/+M="><link rel=apple-touch-icon sizes=180x180 href=https://l1uyun.one/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://l1uyun.one/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://l1uyun.one/favicon-16x16.png><link rel=manifest href=https://l1uyun.one/site.webmanifest><link rel=mask-icon href=https://l1uyun.one/safari-pinned-tab.svg color><link rel="shortcut icon" href=https://l1uyun.one/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="javasec-xxe"><meta itemprop=description content="xxe注入 前置知识 XML文档 要了解XXE漏洞，那么先得了解一下有关XML的基础知识。 XML是一种非常流行的标记语言，在1990年代后期首次标"><meta itemprop=datePublished content="2024-07-26T00:00:00+00:00"><meta itemprop=dateModified content="2024-07-26T00:00:00+00:00"><meta itemprop=wordCount content="3496"><meta itemprop=keywords content="Sec/Javasec"><meta name=twitter:card content="summary"><meta name=twitter:title content="javasec-xxe"><meta name=twitter:description content="xxe注入 前置知识 XML文档 要了解XXE漏洞，那么先得了解一下有关XML的基础知识。 XML是一种非常流行的标记语言，在1990年代后期首次标"><meta property="og:url" content="https://l1uyun.one/posts/2024/07/javasec-xxe/"><meta property="og:site_name" content="l1uyun☁️"><meta property="og:title" content="javasec-xxe"><meta property="og:description" content="xxe注入 前置知识 XML文档 要了解XXE漏洞，那么先得了解一下有关XML的基础知识。 XML是一种非常流行的标记语言，在1990年代后期首次标"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-26T00:00:00+00:00"><meta property="article:tag" content="Sec/Javasec"><meta property="article:published_time" content="2024-07-26 00:00:00 +0000 UTC"><script async src="https://www.googletagmanager.com/gtag/js?id=G-RSXEZVCJT4"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RSXEZVCJT4")</script><link rel=stylesheet href=https://unpkg.com/swiper/swiper-bundle.min.css><script src=https://unpkg.com/swiper/swiper-bundle.min.js></script><link rel=stylesheet href=https://l1uyun.one/css/custom.css></head><body><div class=container><header class=header><span class=header__inner><a href=https://l1uyun.one/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/l1uyun☁️ </span><span class=logo__cursor style=background-color:#87ceeb></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://l1uyun.one/posts/>Posts</a></li><li><a href=https://l1uyun.one/tags/>Tags</a></li><li><a href=https://l1uyun.one/about/>About</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="22" height="22" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p></p><hr><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://l1uyun.one/tags/sec/javasec/>sec/javasec</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-07-26 00:00</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
3496 Words
<span>&nbsp;&nbsp;</span>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
7 minutes</p></div><hr><article><h1 class=post-title><a href=https://l1uyun.one/posts/2024/07/javasec-xxe/>javasec-xxe</a></h1><div class=post-content><h1 id=xxe注入>xxe注入</h1><h2 id=前置知识>前置知识</h2><h3 id=xml文档>XML文档</h3><p>要了解XXE漏洞，那么先得了解一下有关XML的基础知识。</p><p>XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，&mldr;），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML， XACML，&mldr;）</p><h4 id=文档结构>文档结构</h4><p>XML主要由7个部分组成,</p><ul><li>文档声明</li><li>标签/元素</li><li>属性</li><li>注释</li><li>实体字符</li><li>CDATA 字符数据区。CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。CDATA 部分中的所有内容都会被解析器忽略。CDATA 部分由 <code>**</code> 结束，某些文本比如 JavaScript 代码，包含大量 “&lt;” 或 “&” 字符。为了避免错误，可以将脚本代码定义为 CDATA。</li><li>处理指令,</li></ul><p>一个标准的xml文件为</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8b949e;font-style:italic>&lt;!-- XML文档声明；同时也是一个处理指令,用于声明 XML 文档的版本和编码方式。&lt;? xxx ?&gt; 就是处理指令的格式--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>&lt;!-- bookstore根元素、book子元素--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;bookstore&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>&lt;!-- category、lang都是属性--&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;book</span> category=<span style=color:#a5d6ff>&#34;COOKING&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;title</span> lang=<span style=color:#a5d6ff>&#34;en&#34;</span><span style=color:#7ee787>&gt;</span>Everyday Italian<span style=color:#7ee787>&lt;/title&gt;</span> 
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>&lt;!-- &amp;lt;实体字符 是一个预定义的实体引用，这里也可以引用dtd中定义的实体，以 &amp; 开头, 以;结尾--&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;author&gt;</span>Giada De Laurentiis<span style=color:#ffa657>&amp;lt;</span><span style=color:#7ee787>&lt;/author&gt;</span> 
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;year&gt;</span>2005<span style=color:#7ee787>&lt;/year&gt;</span> 
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;price&gt;</span>30.00<span style=color:#7ee787>&lt;/price&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>&lt;!-- script这里是CDATA，不能被xml解析器解析，可以被JavaScript解析--&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;script&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;![CDATA[
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>   function matchwo(a,b)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>   {
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>    if (a &lt; b &amp;&amp; a &lt; 0) then
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>      {return 1;}
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>    else
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>      {return 0;}
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>   }
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>   ]]&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;/script&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;/book&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;/bookstore&gt;</span>
</span></span></code></pre></div><h4 id=dtd>DTD</h4><p>DTD（Document Type Definition）是用来定义 XML 文档的结构和合法元素的集合。<br>DTD 定义了 XML 文档中可以出现的元素、属性和它们的顺序，以确保 XML 数据的格式和结构符合预定义的规则。<br>DTD 可以嵌入到 XML 文档中，也可以外部定义并引用。</p><p>DOCTYPE是DTD的声明<br>!ELEMENT> 声明用于定义 XML 文档中元素的结构和内容模型。它指定了元素的名称及其允许的子元素、文本内容或其他结构。<br>ENTITY是实体的声明，所谓实体可以理解为变量<br>SYSTEM、PUBLIC是外部资源的申请</p><p>从两个角度可以把XML分为两类共4个类型：</p><p>（内部实体、外部实体）</p><p>（通用实体、参数实体）</p><p>1)内部实体<br>所谓内部实体是指在一个实体中定义的另一个实体，也就是嵌套定义。<br><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_1.png><br><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_2.png><br>使用&amp;xxe对上面定义的xxe实体进行了引用，到时候输出的时候&amp;xxe就会被“test”替换。</p><p>在XML内部声明DTD:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;?xml version=&#34;1.0&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!DOCTYPE note [
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>  &lt;!ELEMENT note (to,from,heading,body)&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ELEMENT to      (#PCDATA)&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ELEMENT from    (#PCDATA)&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ELEMENT message (#PCDATA)&gt;</span>
</span></span><span style=display:flex><span>]&gt;
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;note&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;to&gt;</span>George<span style=color:#7ee787>&lt;/to&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;from&gt;</span>John<span style=color:#7ee787>&lt;/from&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;message&gt;</span>Reminder<span style=color:#7ee787>&lt;/message&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;/note&gt;</span>
</span></span></code></pre></div><p>2）外部实体<br>外部实体表示外部文件的内容，用 SYSTEM 关键词表示，通常使用下面的格式来引用</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ENTITY entityName SYSTEM &#34;fileName&#34;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ENTITY example SYSTEM &#34;/etc/passwd&#34;&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ENTITY entityName PUBLIC &#34;publicID&#34; &#34;fileName&#34;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ENTITY example PUBLIC &#34;-//W3C//DTD HTML 4.01 Transitional//EN&#34; &#34;html4-transitional.dtd&#34;&gt;</span>
</span></span></code></pre></div><p><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_3.png><br>有些XML文档包含system标识符定义的“实体”，这些文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。<br>假如 SYSTEM 后面的内容可以被攻击者控制，那么攻击者就可以随意替换为其他内容，从而读取服务器本地文件（file:///etc/passwd）或者远程文件（http://www.baidu.com/abc.txt）。</p><p>3）通用实体<br>用”&实体名“引用的实体，在DTD中定义，在XML文档中引用。<br><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_4.png></p><p>4）参数实体<br>使用<code>% 实体名</code>（这里空格不能少）在 DTD 中定义，并且只能在 DTD 中使用<code>%实体名;</code>引用<br>只有在DTD文件中，参数实体的声明才能引用其他实体<br>和通用实体一样，参数实体也可以外部引用<br><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_5.png></p><h3 id=xxe>XXE</h3><p>XXE（XML External Entity Injection，XML 外部实体注入）是一种安全漏洞，通常发生在解析 XML 数据时。攻击者通过在 XML 文档中注入外部实体来读取本地文件、发送数据到远程服务器，甚至执行其他恶意操作。<br>XXE 攻击可能导致敏感信息泄露、服务拒绝（DoS）攻击等安全问题。</p><p>XXE漏洞之所以名为外部实体漏洞，就是因为问题主要出自于外部资源的申请以及外部实体的引用这部分特性中。我们从XXE的全称（XML外部实体注入）可以看出，XXE也是一种XML注入，只不过注入的是XML外部实体罢了。<br><img alt=|500 src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_6.png></p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!DOCTYPE foo [  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>  &lt;!ELEMENT foo ANY &gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;!ENTITY xxe SYSTEM &#34;file:///etc/passwd&#34; &gt;</span>]&gt;<span style=color:#7ee787>&lt;foo&gt;</span><span style=color:#ffa657>&amp;xxe;</span><span style=color:#7ee787>&lt;/foo&gt;</span>
</span></span></code></pre></div><p>在这个示例中，<code>&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" > </code>定义了一个外部实体 xxe，指向本地文件 /etc/passwd。<br>当 XML 解析器解析这个 XML 数据时，它会尝试读取 /etc/passwd 文件的内容并将其插入到 &amp;xxe; 标签中。</p><h3 id=java-解析xml的四种方式>Java 解析XML的四种方式</h3><ol><li><p>DOM（Document Object Model）解析</p><ul><li>DocumentBuilder: 用于解析 XML 数据并构建 DOM 文档对象模型。属于 JAXP（Java API for XML Processing）。</li><li>DOMParser: 一般指 DOM 解析器的实现（如 org.w3c.dom.DocumentBuilder）。它用于将 XML 数据解析成 DOM 文档结构。</li></ul></li><li><p>SAX（Simple API for XML）解析</p><ul><li>SAXParser: SAX 解析器，用于逐行读取 XML 数据，并触发相应的事件。属于 JAXP（Java API for XML Processing）。</li><li>Unmarshaller: JAXB 中的组件，用于将 XML 数据转换为 Java 对象。虽然它在 JAXB 中不直接属于 SAX，但它可以配置 SAX 解析器来处理 XML 数据。</li></ul></li><li><p>JDOM 解析</p><ul><li>SAXBuilder: JDOM 提供的一个类，用于通过 SAX 解析器构建 JDOM 文档对象模型。JDOM 是一个独立的 XML 处理库，与 DOM4J 和 JAXB 不同。</li></ul></li><li><p>DOM4J（Document Object Model for Java）解析</p><ul><li>SAXReader: DOM4J 提供的一个类，用于使用 SAX 解析 XML 数据。实际上，SAXReader 是 DOM4J 的一部分，而不是独立的 SAX 解析器。</li></ul></li></ol><h2 id=复现平台>复现平台</h2><p><a href=https://github.com/j3ers3/Hello-Java-Sec>Hello-Java-Sec</a><br><a href=https://github.com/bewhale/JavaSec>JavaSec</a></p><h2 id=漏洞分析>漏洞分析</h2><p>按照这两个平台提供的资源,来看看具体的漏洞代码</p><h3 id=xmlreader>XMLReader</h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * XMLReader 是一个接口，用于解析 XML 文档。它是 SAX (Simple API for XML) 的核心组件之一。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 它提供了对 XML 文档的逐行读取和解析功能，并将事件传递给相应的处理器。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 使用 XMLReader 时，需要注意安全问题，例如防止 XML 外部实体注入攻击。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681> 
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#8b949e;font-style:italic>// payload: &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &#34;dsm6kqkg.dnslog.pw&#34;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>XMLReader</span>(<span style=color:#d2a8ff;font-weight:700>@RequestBody</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>XMLReader<span style=color:#6e7681> </span>xmlReader<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>XMLReaderFactory.createXMLReader();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// 修复：禁用外部实体</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// xmlReader.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>xmlReader.parse(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>InputSource(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>StringReader(content)));<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;XMLReader XXE&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681> </span><span style=color:#ff7b72>catch</span><span style=color:#6e7681> </span>(Exception<span style=color:#6e7681> </span>e)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>e.toString();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_2.png><br>修复方法就是上面代码中的,setFeature,禁用外部实体</p><h3 id=saxparser>SAXParser</h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * javax.xml.parsers.SAXParser 是 XMLReader 的替代品，它提供了更多的安全措施，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 例如默认禁用 DTD 和外部实体的声明。如果需要使用 DTD 或外部实体，可以手动启用它们，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 并使用相应的安全措施。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#d2a8ff;font-weight:700>@ApiOperation</span>(value<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;vul：SAXParser&#34;</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#d2a8ff;font-weight:700>@RequestMapping</span>(value<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;/SAXParser&#34;</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>SAXParser</span>(<span style=color:#d2a8ff;font-weight:700>@RequestParam</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span>SAXParserFactory<span style=color:#6e7681> </span>factory<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>SAXParserFactory.newInstance();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span>SAXParser<span style=color:#6e7681> </span>parser<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>factory.newSAXParser();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span>parser.parse(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>InputSource(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>StringReader(content)),<span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>DefaultHandler());<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;SAXParser XXE&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span>}<span style=color:#6e7681> </span><span style=color:#ff7b72>catch</span><span style=color:#6e7681> </span>(Exception<span style=color:#6e7681> </span>e)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>e.toString();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>会有报错信息,但是dnslog弹成功了<br><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_7.png><br><img src=https://img.l1uyun.one/javasec-xxe%E6%B3%A8%E5%85%A5_image_8.png></p><h3 id=saxreader>SAXReader</h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * SAXReader 是一个用于读取和解析 XML 文档的类。它基于 SAX (Simple API for XML) 实现，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 提供了简单的 API 以便快速解析 XML。SAXReader 通常用于处理大规模 XML 数据流。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 在使用 SAXReader 时，需要采取相应的安全措施来防止 XML 外部实体注入等攻击。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#d2a8ff;font-weight:700>@ApiOperation</span>(value<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;vul：SAXReader&#34;</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#d2a8ff;font-weight:700>@RequestMapping</span>(value<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;/SAXReader&#34;</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>SAXReader</span>(<span style=color:#d2a8ff;font-weight:700>@RequestParam</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span>SAXReader<span style=color:#6e7681> </span>sax<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>SAXReader();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span><span style=color:#8b949e;font-style:italic>// 修复：禁用外部实体</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span><span style=color:#8b949e;font-style:italic>// sax.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span>sax.read(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>InputSource(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>StringReader(content)));<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;SAXReader XXE&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span>}<span style=color:#6e7681> </span><span style=color:#ff7b72>catch</span><span style=color:#6e7681> </span>(Exception<span style=color:#6e7681> </span>e)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>		</span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>e.toString();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>	</span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id=saxbuilder>SAXBuilder</h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * SAXBuilder 是一个用于构建 JDOM (Java Document Object Model) 文档的类。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 它基于 SAX 解析器，将 XML 数据解析为 JDOM 文档对象。SAXBuilder 提供了易于使用的 API，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 使得在内存中操作 XML 文档更加方便。在使用 SAXBuilder 时，应确保配置正确的安全设置，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 以防止潜在的 XML 处理漏洞。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#d2a8ff;font-weight:700>@RequestMapping</span>(value<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;/SAXBuilder&#34;</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>SAXBuilder</span>(<span style=color:#d2a8ff;font-weight:700>@RequestBody</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>SAXBuilder<span style=color:#6e7681> </span>saxbuilder<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>SAXBuilder();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// 修复: saxbuilder.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>saxbuilder.build(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>InputSource(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>StringReader(content)));<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;SAXBuilder XXE&#34;</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681> </span><span style=color:#ff7b72>catch</span><span style=color:#6e7681> </span>(Exception<span style=color:#6e7681> </span>e)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>e.toString();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id=documentbuilder>DocumentBuilder</h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * DocumentBuilder 是用于构建和解析 XML 文档的类，它是基于 DOM (Document Object Model) 的实现。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * DocumentBuilder 提供了创建、解析、修改 XML 文档的功能，并支持各种解析选项。在使用 DocumentBuilder 时，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 需要注意配置安全选项，例如禁用外部实体和 DTD，以防止潜在的安全漏洞。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>DocumentBuilderFactory<span style=color:#6e7681> </span>factory<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>DocumentBuilderFactory.newInstance();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#8b949e;font-style:italic>// 修复: 禁用外部实体</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#8b949e;font-style:italic>// factory.setFeature(&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;, true);</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>DocumentBuilder<span style=color:#6e7681> </span>builder<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>factory.newDocumentBuilder();<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id=unmarshaller>Unmarshaller</h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * Unmarshaller 是 JAXB (Java Architecture for XML Binding) 的核心组件之一，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 它将 XML 数据转换为 Java 对象。Unmarshaller 提供了将 XML 数据映射到相应 Java 类的功能，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 并支持各种自定义配置。在使用 Unmarshaller 时，需要注意处理 XML 数据中的外部实体和 DTD，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 以确保安全性。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>  *  PoC
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>  * Content-Type: application/xml
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>  * &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;!DOCTYPE student[&lt;!ENTITY out SYSTEM &#34;file:///etc/hosts&#34;&gt;]&gt;&lt;student&gt;&lt;name&gt;&amp;out;&lt;/name&gt;&lt;/student&gt;
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>  */</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>Unmarshaller</span>(<span style=color:#d2a8ff;font-weight:700>@RequestBody</span><span style=color:#6e7681> </span>String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>try</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>JAXBContext<span style=color:#6e7681> </span>context<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>JAXBContext.newInstance(Student.class);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>Unmarshaller<span style=color:#6e7681> </span>unmarshaller<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>context.createUnmarshaller();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>XMLInputFactory<span style=color:#6e7681> </span>xif<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>XMLInputFactory.newFactory();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// 修复: 禁用外部实体</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &#34;&#34;);</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#8b949e;font-style:italic>// xif.setProperty(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &#34;&#34;);</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>XMLStreamReader<span style=color:#6e7681> </span>xsr<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>xif.createXMLStreamReader(<span style=color:#ff7b72>new</span><span style=color:#6e7681> </span>StringReader(content));<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>Object<span style=color:#6e7681> </span>o<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>unmarshaller.unmarshal(xsr);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>o.toString();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681> </span><span style=color:#ff7b72>catch</span><span style=color:#6e7681> </span>(Exception<span style=color:#6e7681> </span>e)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>e.printStackTrace();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h2 id=漏洞修复>漏洞修复</h2><p>一方面是禁用外部实体</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#a5d6ff>&#34;http://apache.org/xml/features/disallow-doctype-decl&#34;</span>, <span style=color:#79c0ff>true</span> 
</span></span><span style=display:flex><span><span style=color:#a5d6ff>&#34;http://apache.org/xml/features/nonvalidating/load-external-dtd&#34;</span>, <span style=color:#79c0ff>false</span>
</span></span><span style=display:flex><span><span style=color:#a5d6ff>&#34;http://xml.org/sax/features/external-general-entities&#34;</span>, <span style=color:#79c0ff>false</span>
</span></span><span style=display:flex><span><span style=color:#a5d6ff>&#34;http://xml.org/sax/features/external-parameter-entities&#34;</span>, <span style=color:#79c0ff>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>XMLConstants.ACCESS_EXTERNAL_DTD, <span style=color:#a5d6ff>&#34;&#34;</span>
</span></span><span style=display:flex><span>XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span style=color:#a5d6ff>&#34;&#34;</span>
</span></span></code></pre></div><p>另一方面可以使用黑名单过滤掉外部实体中的关键词,这两个关键字是定义外部实体和文档类型声明的标志&mldr;不过貌似有上面的禁用就够了</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>static</span><span style=color:#6e7681> </span><span style=color:#ff7b72>boolean</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>checkXXE</span>(String<span style=color:#6e7681> </span>content)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>String<span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>black_list<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>{<span style=color:#a5d6ff>&#34;ENTITY&#34;</span>,<span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;DOCTYPE&#34;</span>};<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(String<span style=color:#6e7681> </span>s<span style=color:#6e7681> </span>:<span style=color:#6e7681> </span>black_list)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#ff7b72>if</span><span style=color:#6e7681> </span>(content.toUpperCase().contains(s))<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>            </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#79c0ff>true</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span><span style=color:#79c0ff>false</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h2 id=漏洞发现>漏洞发现</h2><p>是否禁止dtd或者entity<br>参数是否可控<br>传入参数格式为REST XML格式，X-RequestEntity-ContentType: application/xml</p><p>黑盒找是否有参数是xml数据,如果有的话,直接上payload测测<br>白盒,搜索关键函数,进行代码审计</p><pre tabindex=0><code> * 审计的函数
 * 1. XMLReader
 * 2. SAXReader
 * 3. DocumentBuilder
 * 4. XMLStreamReader
 * 5. SAXBuilder
 * 6. SAXParser
 * 7. SAXSource
 * 8. TransformerFactory
 * 9. SAXTransformerFactory
 * 10. SchemaFactory
 * 11. Unmarshaller
 * 12. XPathExpression
</code></pre><h1 id=一句话总结>一句话总结</h1><p>在 Java 中，XXE（XML 外部实体注入）漏洞与其他语言类似：攻击者通过不安全的 XML 解析配置，在 XML 文档中注入恶意外部实体，能够读取本地文件、发起远程请求或执行其他恶意操作。</p><h1 id=参考>参考</h1><p>小迪sec<br><a href=https://www.cnblogs.com/LittleHann/p/17776458.html>Java XXE漏洞原理研究</a></p></div></article><hr><div class=pagination><div class=pagination__buttons><span class="button next"><a href=https://l1uyun.one/posts/2024/07/javasec-sql%E6%B3%A8%E5%85%A5/><span class=button__text>javasec-sql注入</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=L1uYun/l1uyun_blog label="blog comment" issue-term=title theme=github-light crossorigin=anonymous async></script></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2024</span>
<span><a href=https://l1uyun.one/></a></span><span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://l1uyun.one/posts/index.xml target=_blank title=rss><svg width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span><span>Made with &#10084; by <a href=https://github.com/rhazdon>Djordje Atlialp</a></span></div></div></footer></div><script type=text/javascript src=https://l1uyun.one/bundle.min.243fec32d3a4ae91a0f3d22849096c696784566f8bf3d340ce4ebfd711d99f3cac4489fe226e2645c6c5c284d863f37ddc0d610af7b3fa108a2d4387981d3db7.js integrity="sha512-JD/sMtOkrpGg89IoSQlsaWeEVm+L89NAzk6/1xHZnzysRIn+Im4mRcbFwoTYY/N93A1hCvez+hCKLUOHmB09tw=="></script><script src=https://l1uyun.one/js/view-image.min.js></script><script>window.ViewImage&&ViewImage.init(".content img")</script></body></html>